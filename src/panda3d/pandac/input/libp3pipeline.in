1577202526
3 3
13 libp3pipeline 4 kd_i 12 panda3d.core 
110
105 29 upcast_to_TypedReferenceCount 0 12 216 37 Thread::upcast_to_TypedReferenceCount 0 1 31 41
upcast from Thread to TypedReferenceCount
65
TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void);

106 18 downcast_to_Thread 0 12 217 39 TypedReferenceCount::downcast_to_Thread 0 0 43
downcast from TypedReferenceCount to Thread
54
Thread *TypedReferenceCount::downcast_to_Thread(void);

107 17 upcast_to_Namable 0 12 216 25 Thread::upcast_to_Namable 0 1 32 29
upcast from Thread to Namable
41
Namable *Thread::upcast_to_Namable(void);

108 18 downcast_to_Thread 0 12 218 27 Namable::downcast_to_Thread 0 0 31
downcast from Namable to Thread
42
Thread *Namable::downcast_to_Thread(void);

109 7 ~Thread 0 6 216 15 Thread::~Thread 0 0 10
/**
 *
 */
30
virtual Thread::~Thread(void);

110 11 bind_thread 0 4 216 19 Thread::bind_thread 0 1 1 952
/**
 * Returns a new Panda Thread object associated with the current thread (which
 * has been created externally). This can be used to bind a unique Panda
 * Thread object with an external thread, such as a new Python thread.
 *
 * It is particularly useful to bind a Panda Thread object to an external
 * thread for the purposes of PStats monitoring.  Without this call, each
 * external thread will be assigned the same global ExternalThread object,
 * which means they will all appear in the same PStats graph.
 *
 * It is the caller's responsibility to save the returned Thread pointer for
 * the lifetime of the external thread.  It is an error for the Thread pointer
 * to destruct while the external thread is still in the system.
 *
 * It is also an error to call this method from the main thread, or twice
 * within a given thread, unless it is given the same name each time (in which
 * case the same pointer will be returned each time).
 */
102
static PointerTo< Thread > Thread::bind_thread(std::string const &name, std::string const &sync_name);

111 13 get_sync_name 0 4 216 21 Thread::get_sync_name 0 1 2 279
/**
 * Returns the sync name of the thread.  This name collects threads into "sync
 * groups", which are expected to run synchronously.  This is mainly used for
 * the benefit of PStats; threads with the same sync name can be ticked all at
 * once via the thread_tick() call.
 */
60
inline std::string const &Thread::get_sync_name(void) const;

112 16 get_pstats_index 0 4 216 24 Thread::get_pstats_index 0 1 3 218
/**
 * Returns the PStats index associated with this thread, or -1 if no index has
 * yet been associated with this thread.  This is used internally by the
 * PStatClient; you should not need to call this directly.
 */
48
inline int Thread::get_pstats_index(void) const;

113 16 get_python_index 0 4 216 24 Thread::get_python_index 0 1 4 233
/**
 * Returns the Python index associated with this thread, or -1 if no index has
 * yet been associated with this thread.  This is used internally by the
 * direct.stdpy.thread module; you should not need to call this directly.
 */
48
inline int Thread::get_python_index(void) const;

114 13 get_unique_id 0 4 216 21 Thread::get_unique_id 0 1 5 161
/**
 * Returns a string that is guaranteed to be unique to this thread, across all
 * processes on the machine, during at least the lifetime of this process.
 */
53
inline std::string Thread::get_unique_id(void) const;

115 18 get_pipeline_stage 0 4 216 26 Thread::get_pipeline_stage 0 1 6 163
/**
 * Returns the Pipeline stage number associated with this thread.  The default
 * stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().
 */
50
inline int Thread::get_pipeline_stage(void) const;

116 18 set_pipeline_stage 0 4 216 26 Thread::set_pipeline_stage 0 1 7 479
/**
 * Specifies the Pipeline stage number associated with this thread.  The
 * default stage is 0 if no stage is specified otherwise.
 *
 * This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
 * It specifies the values that this thread observes for all pipelined data.
 * Typically, an application thread will leave this at 0, but a render thread
 * may set it to 1 or 2 (to operate on the previous frame's data, or the
 * second previous frame's data).
 */
52
void Thread::set_pipeline_stage(int pipeline_stage);

117 22 set_min_pipeline_stage 0 4 216 30 Thread::set_min_pipeline_stage 0 1 8 143
/**
 * Sets this thread's pipeline stage number to at least the indicated value,
 * unless it is already larger.  See set_pipeline_stage().
 */
67
inline void Thread::set_min_pipeline_stage(int min_pipeline_stage);

118 15 get_main_thread 0 4 216 23 Thread::get_main_thread 0 1 9 111
/**
 * Returns a pointer to the "main" Thread object--this is the Thread that
 * started the whole process.
 */
52
static inline Thread *Thread::get_main_thread(void);

119 19 get_external_thread 0 4 216 27 Thread::get_external_thread 0 1 10 248
/**
 * Returns a pointer to the "external" Thread object--this is a special Thread
 * object that corresponds to any thread spawned outside of Panda's threading
 * interface.  Note that multiple different threads may share this same
 * pointer.
 */
56
static inline Thread *Thread::get_external_thread(void);

120 18 get_current_thread 0 4 216 26 Thread::get_current_thread 0 1 11 415
/**
 * Returns a pointer to the currently-executing Thread object.  If this is
 * called from the main thread, this will return the same value as
 * get_main_thread().
 *
 * This will always return some valid Thread pointer.  It will never return
 * NULL, even if the current thread was spawned outside of Panda's threading
 * system, although all non-Panda threads will return the exact same Thread
 * pointer.
 */
55
static inline Thread *Thread::get_current_thread(void);

121 26 get_current_pipeline_stage 0 4 216 34 Thread::get_current_pipeline_stage 0 1 12 208
/**
 * Returns the integer pipeline stage associated with the current thread.
 * This is the same thing as get_current_thread()->get_pipeline_stage(), but
 * it may be faster to retrieve in some contexts.
 */
59
static inline int Thread::get_current_pipeline_stage(void);

122 22 is_threading_supported 0 4 216 30 Thread::is_threading_supported 0 1 13 159
/**
 * Returns true if threading support has been compiled in and enabled, or
 * false if no threading is available (and Thread::start() will always fail).
 */
56
static inline bool Thread::is_threading_supported(void);

123 15 is_true_threads 0 4 216 23 Thread::is_true_threads 0 1 14 196
/**
 * Returns true if a real threading library is available that supports actual
 * OS-implemented threads, or false if the only threading we can provide is
 * simulated user-space threading.
 */
49
static inline bool Thread::is_true_threads(void);

124 17 is_simple_threads 0 4 216 25 Thread::is_simple_threads 0 1 15 393
/**
 * Returns true if Panda is currently compiled for "simple threads", which is
 * to say, cooperative context switching only, reducing the need for quite so
 * many critical section protections.  This is not necessarily the opposite of
 * "true threads", since one possible implementation of simple threads is via
 * true threads with mutex protection to ensure only one runs at a time.
 */
51
static inline bool Thread::is_simple_threads(void);

125 5 sleep 0 4 216 13 Thread::sleep 0 1 16 119
/**
 * Suspends the current thread for at least the indicated amount of time.  It
 * might be suspended for longer.
 */
49
static inline void Thread::sleep(double seconds);

126 11 force_yield 0 4 216 19 Thread::force_yield 0 1 17 73
/**
 * Suspends the current thread for the rest of the current epoch.
 */
45
static inline void Thread::force_yield(void);

127 14 consider_yield 0 4 216 22 Thread::consider_yield 0 1 18 239
/**
 * Possibly suspends the current thread for the rest of the current epoch, if
 * it has run for enough this epoch.  This is especially important for the
 * simple thread implementation, which relies on cooperative yields like this.
 */
48
static inline void Thread::consider_yield(void);

128 6 output 0 6 216 14 Thread::output 0 1 19 10
/**
 *
 */
53
virtual void Thread::output(std::ostream &out) const;

129 14 output_blocker 0 4 216 22 Thread::output_blocker 0 1 20 184
/**
 * Writes a description of the mutex or condition variable that this thread is
 * blocked on.  Writes nothing if there is no blocker, or if we are not in
 * DEBUG_THREADS mode.
 */
53
void Thread::output_blocker(std::ostream &out) const;

130 12 write_status 0 4 216 20 Thread::write_status 0 1 21 10
/**
 *
 */
52
static void Thread::write_status(std::ostream &out);

131 10 is_started 0 4 216 18 Thread::is_started 0 1 22 117
/**
 * Returns true if the thread has been started, false if it has not, or if
 * join() has already been called.
 */
43
inline bool Thread::is_started(void) const;

132 11 is_joinable 0 4 216 19 Thread::is_joinable 0 1 23 77
/**
 * Returns the value of joinable that was passed to the start() call.
 */
44
inline bool Thread::is_joinable(void) const;

133 5 start 0 4 216 13 Thread::start 0 1 24 862
/**
 * Starts the thread executing.  It is only valid to call this once.
 *
 * The thread will begin executing its thread_main() function, and will
 * terminate when thread_main() returns.
 *
 * priority is intended as a hint to the relative importance of this thread.
 * This may be ignored by the thread implementation.
 *
 * joinable should be set true if you intend to call join() to wait for the
 * thread to terminate, or false if you don't care and you will never call
 * join(). Note that the reference count on the Thread object is incremented
 * while the thread itself is running, so if you just want to fire and forget
 * a thread, you may pass joinable = false, and never store the Thread object.
 * It will automatically destruct itself when it finishes.
 *
 * The return value is true if the thread is successfully started, false
 * otherwise.
 */
59
bool Thread::start(ThreadPriority priority, bool joinable);

134 4 join 0 4 216 12 Thread::join 0 1 25 134
/**
 * Blocks the calling process until the thread terminates.  If the thread has
 * already terminated, this returns immediately.
 */
31
inline void Thread::join(void);

135 7 preempt 0 4 216 15 Thread::preempt 0 1 26 183
/**
 * Indicates that this thread should run as soon as possible, preemptying any
 * other threads that may be scheduled to run.  This may not be implemented on
 * every platform.
 */
34
inline void Thread::preempt(void);

136 16 get_current_task 0 4 216 24 Thread::get_current_task 0 1 27 161
/**
 * Returns the task currently executing on this thread (via the
 * AsyncTaskManager), if any, or NULL if the thread is not currently servicing
 * a task.
 */
65
inline TypedReferenceCount *Thread::get_current_task(void) const;

137 16 set_python_index 0 4 216 24 Thread::set_python_index 0 1 28 160
/**
 * Stores a Python index to be associated with this thread.  This is used
 * internally by the thread module; you should not need to call this directly.
 */
48
inline void Thread::set_python_index(int index);

138 16 prepare_for_exit 0 4 216 24 Thread::prepare_for_exit 0 1 29 143
/**
 * Should be called by the main thread just before exiting the program, this
 * blocks until any remaining thread cleanup has finished.
 */
50
static inline void Thread::prepare_for_exit(void);

139 14 get_class_type 0 4 216 22 Thread::get_class_type 0 1 30 0
47
static TypeHandle Thread::get_class_type(void);

140 7 acquire 0 4 226 20 MutexDirect::acquire 0 1 33 405
/**
 * Grabs the mutex if it is available.  If it is not available, blocks until
 * it becomes available, then grabs it.  In either case, the function does not
 * return until the mutex is held; you should then call unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * mutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see MutexHolder.
 */
45
inline void MutexDirect::acquire(void) const;

141 11 try_acquire 0 4 226 24 MutexDirect::try_acquire 0 1 34 204
/**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */
49
inline bool MutexDirect::try_acquire(void) const;

142 7 release 0 4 226 20 MutexDirect::release 0 1 35 247
/**
 * Releases the mutex.  It is an error to call this if the mutex was not
 * already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * mutexes, mainly to allow thread-safe access to otherwise const data.
 */
45
inline void MutexDirect::release(void) const;

143 15 debug_is_locked 0 4 226 28 MutexDirect::debug_is_locked 0 1 36 278
/**
 * Returns true if the current thread has locked the Mutex, false otherwise.
 * This method is only intended for use in debugging, hence the method name;
 * in the MutexDirect case, it always returns true, since there's not a
 * reliable way to determine this otherwise.
 */
53
inline bool MutexDirect::debug_is_locked(void) const;

144 8 set_name 0 4 226 21 MutexDirect::set_name 0 1 37 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
59
inline void MutexDirect::set_name(std::string const &name);

145 10 clear_name 0 4 226 23 MutexDirect::clear_name 0 1 38 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
42
inline void MutexDirect::clear_name(void);

146 8 has_name 0 4 226 21 MutexDirect::has_name 0 1 39 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
46
inline bool MutexDirect::has_name(void) const;

147 8 get_name 0 4 226 21 MutexDirect::get_name 0 1 40 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
53
inline std::string MutexDirect::get_name(void) const;

148 6 output 0 4 226 19 MutexDirect::output 0 1 41 92
/**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * MutexDirect.
 */
50
void MutexDirect::output(std::ostream &out) const;

149 5 Mutex 0 4 227 12 Mutex::Mutex 0 2 42 43 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
81
inline Mutex::Mutex(void);
inline explicit Mutex::Mutex(std::string const &name);

150 6 ~Mutex 0 4 227 13 Mutex::~Mutex 0 0 0
30
Mutex::~Mutex(void) = default;

151 7 acquire 0 4 227 14 Mutex::acquire 0 1 44 0
48
bool Mutex::acquire(bool blocking = true) const;

152 9 __enter__ 0 4 227 16 Mutex::__enter__ 0 1 45 0
28
bool Mutex::__enter__(void);

153 8 __exit__ 0 4 227 15 Mutex::__exit__ 0 1 46 0
57
void Mutex::__exit__(PyObject *, PyObject *, PyObject *);

154 19 ~ConditionVarDirect 0 4 228 39 ConditionVarDirect::~ConditionVarDirect 0 0 0
56
ConditionVarDirect::~ConditionVarDirect(void) = default;

155 9 get_mutex 0 4 228 29 ConditionVarDirect::get_mutex 0 1 47 69
/**
 * Returns the mutex associated with this condition variable.
 */
62
inline MutexDirect &ConditionVarDirect::get_mutex(void) const;

156 4 wait 0 4 228 24 ConditionVarDirect::wait 0 2 48 49 1192
/**
 * Waits on the condition.  The caller must already be holding the lock
 * associated with the condition variable before calling this function.
 *
 * wait() will release the lock, then go to sleep until some other thread
 * calls notify() on this condition variable.  At that time at least one
 * thread waiting on the same ConditionVarDirect will grab the lock again, and
 * then return from wait().
 *
 * It is possible that wait() will return even if no one has called notify().
 * It is the responsibility of the calling process to verify the condition on
 * return from wait, and possibly loop back to wait again if necessary.
 *
 * Note the semantics of a condition variable: the mutex must be held before
 * wait() is called, and it will still be held when wait() returns.  However,
 * it will be temporarily released during the wait() call itself.
 */

/**
 * Waits on the condition, with a timeout.  The function will return when the
 * condition variable is notified, or the timeout occurs.  There is no way to
 * directly tell which happened, and it is possible that neither in fact
 * happened (spurious wakeups are possible).
 *
 * See wait() with no parameters for more.
 */
97
inline void ConditionVarDirect::wait(void);
inline void ConditionVarDirect::wait(double timeout);

157 6 notify 0 4 228 26 ConditionVarDirect::notify 0 1 50 398
/**
 * Informs one of the other threads who are currently blocked on wait() that
 * the relevant condition has changed.  If multiple threads are currently
 * waiting, at least one of them will be woken up, although there is no way to
 * predict which one.  It is possible that more than one thread will be woken
 * up.
 *
 * If no threads are waiting, this is a no-op: the notify event is lost.
 */
45
inline void ConditionVarDirect::notify(void);

158 10 notify_all 0 4 228 30 ConditionVarDirect::notify_all 0 1 51 199
/**
 * Informs all of the other threads who are currently blocked on wait() that
 * the relevant condition has changed.
 *
 * If no threads are waiting, this is a no-op: the notify event is lost.
 */
49
inline void ConditionVarDirect::notify_all(void);

159 6 output 0 4 228 26 ConditionVarDirect::output 0 1 52 106
/**
 * This method is declared virtual in ConditionVarDebug, but non-virtual in
 * ConditionVarDirect.
 */
57
void ConditionVarDirect::output(std::ostream &out) const;

160 12 ConditionVar 0 4 229 26 ConditionVar::ConditionVar 0 1 53 278
/**
 * You must pass in a Mutex to the condition variable constructor.  This mutex
 * may be shared by other condition variables, if desired.  It is the caller's
 * responsibility to ensure the Mutex object does not destruct during the
 * lifetime of the condition variable.
 */
57
inline explicit ConditionVar::ConditionVar(Mutex &mutex);

161 13 ~ConditionVar 0 4 229 27 ConditionVar::~ConditionVar 0 0 0
44
ConditionVar::~ConditionVar(void) = default;

162 9 get_mutex 0 4 229 23 ConditionVar::get_mutex 0 1 54 69
/**
 * Returns the mutex associated with this condition variable.
 */
50
inline Mutex &ConditionVar::get_mutex(void) const;

163 7 acquire 0 4 231 22 ReMutexDirect::acquire 0 2 55 56 541
/**
 * Grabs the reMutex if it is available.  If it is not available, blocks until
 * it becomes available, then grabs it.  In either case, the function does not
 * return until the reMutex is held; you should then call unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * reMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see ReMutexHolder.
 */

/**
 * This variant on acquire() accepts the current thread as a parameter, if it
 * is already known, as an optimization.
 */
113
inline void ReMutexDirect::acquire(void) const;
inline void ReMutexDirect::acquire(Thread *current_thread) const;

164 11 try_acquire 0 4 231 26 ReMutexDirect::try_acquire 0 2 57 58 410
/**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */

/**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */
121
inline bool ReMutexDirect::try_acquire(void) const;
inline bool ReMutexDirect::try_acquire(Thread *current_thread) const;

165 12 elevate_lock 0 4 231 27 ReMutexDirect::elevate_lock 0 1 59 468
/**
 * This method increments the lock count, assuming the calling thread already
 * holds the lock.  After this call, release() will need to be called one
 * additional time to release the lock.
 *
 * This method really performs the same function as acquire(), but it offers a
 * potential (slight) performance benefit when the calling thread knows that
 * it already holds the lock.  It is an error to call this when the calling
 * thread does not hold the lock.
 */
52
inline void ReMutexDirect::elevate_lock(void) const;

166 7 release 0 4 231 22 ReMutexDirect::release 0 1 60 253
/**
 * Releases the reMutex.  It is an error to call this if the reMutex was not
 * already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * reMutexes, mainly to allow thread-safe access to otherwise const data.
 */
47
inline void ReMutexDirect::release(void) const;

167 15 debug_is_locked 0 4 231 30 ReMutexDirect::debug_is_locked 0 1 61 282
/**
 * Returns true if the current thread has locked the ReMutex, false otherwise.
 * This method is only intended for use in debugging, hence the method name;
 * in the ReMutexDirect case, it always returns true, since there's not a
 * reliable way to determine this otherwise.
 */
55
inline bool ReMutexDirect::debug_is_locked(void) const;

168 8 set_name 0 4 231 23 ReMutexDirect::set_name 0 1 62 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
61
inline void ReMutexDirect::set_name(std::string const &name);

169 10 clear_name 0 4 231 25 ReMutexDirect::clear_name 0 1 63 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
44
inline void ReMutexDirect::clear_name(void);

170 8 has_name 0 4 231 23 ReMutexDirect::has_name 0 1 64 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
48
inline bool ReMutexDirect::has_name(void) const;

171 8 get_name 0 4 231 23 ReMutexDirect::get_name 0 1 65 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
55
inline std::string ReMutexDirect::get_name(void) const;

172 6 output 0 4 231 21 ReMutexDirect::output 0 1 66 94
/**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * ReMutexDirect.
 */
52
void ReMutexDirect::output(std::ostream &out) const;

173 7 ReMutex 0 4 232 16 ReMutex::ReMutex 0 2 67 68 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
89
inline ReMutex::ReMutex(void);
inline explicit ReMutex::ReMutex(std::string const &name);

174 8 ~ReMutex 0 4 232 17 ReMutex::~ReMutex 0 0 0
34
ReMutex::~ReMutex(void) = default;

175 7 acquire 0 4 232 16 ReMutex::acquire 0 1 69 0
50
bool ReMutex::acquire(bool blocking = true) const;

176 9 __enter__ 0 4 232 18 ReMutex::__enter__ 0 1 70 0
30
bool ReMutex::__enter__(void);

177 8 __exit__ 0 4 232 17 ReMutex::__exit__ 0 1 71 0
59
void ReMutex::__exit__(PyObject *, PyObject *, PyObject *);

178 14 get_class_type 0 4 233 30 ExternalThread::get_class_type 0 1 72 0
55
static TypeHandle ExternalThread::get_class_type(void);

179 15 ~ExternalThread 0 4 233 31 ExternalThread::~ExternalThread 0 0 0
38
ExternalThread::~ExternalThread(void);

180 7 acquire 0 4 234 25 LightMutexDirect::acquire 0 1 73 428
/**
 * Grabs the lightMutex if it is available.  If it is not available, blocks
 * until it becomes available, then grabs it.  In either case, the function
 * does not return until the lightMutex is held; you should then call
 * unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * lightMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see LightMutexHolder.
 */
50
inline void LightMutexDirect::acquire(void) const;

181 7 release 0 4 234 25 LightMutexDirect::release 0 1 74 262
/**
 * Releases the lightMutex.  It is an error to call this if the lightMutex was
 * not already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * lightMutexes, mainly to allow thread-safe access to otherwise const data.
 */
50
inline void LightMutexDirect::release(void) const;

182 15 debug_is_locked 0 4 234 33 LightMutexDirect::debug_is_locked 0 1 75 289
/**
 * Returns true if the current thread has locked the LightMutex, false
 * otherwise.  This method is only intended for use in debugging, hence the
 * method name; in the LightMutexDirect case, it always returns true, since
 * there's not a reliable way to determine this otherwise.
 */
58
inline bool LightMutexDirect::debug_is_locked(void) const;

183 8 set_name 0 4 234 26 LightMutexDirect::set_name 0 1 76 84
/**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */
64
inline void LightMutexDirect::set_name(std::string const &name);

184 10 clear_name 0 4 234 28 LightMutexDirect::clear_name 0 1 77 84
/**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */
47
inline void LightMutexDirect::clear_name(void);

185 8 has_name 0 4 234 26 LightMutexDirect::has_name 0 1 78 84
/**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */
51
inline bool LightMutexDirect::has_name(void) const;

186 8 get_name 0 4 234 26 LightMutexDirect::get_name 0 1 79 84
/**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */
58
inline std::string LightMutexDirect::get_name(void) const;

187 6 output 0 4 234 24 LightMutexDirect::output 0 1 80 102
/**
 * This method is declared virtual in LightMutexDebug, but non-virtual in
 * LightMutexDirect.
 */
55
void LightMutexDirect::output(std::ostream &out) const;

188 10 LightMutex 0 4 235 22 LightMutex::LightMutex 0 2 81 82 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
101
inline LightMutex::LightMutex(void);
inline explicit LightMutex::LightMutex(std::string const &name);

189 11 ~LightMutex 0 4 235 23 LightMutex::~LightMutex 0 0 0
40
LightMutex::~LightMutex(void) = default;

190 7 acquire 0 4 236 27 LightReMutexDirect::acquire 0 2 83 84 564
/**
 * Grabs the lightReMutex if it is available.  If it is not available, blocks
 * until it becomes available, then grabs it.  In either case, the function
 * does not return until the lightReMutex is held; you should then call
 * unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * lightReMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see LightReMutexHolder.
 */

/**
 * This variant on acquire() accepts the current thread as a parameter, if it
 * is already known, as an optimization.
 */
123
inline void LightReMutexDirect::acquire(void) const;
inline void LightReMutexDirect::acquire(Thread *current_thread) const;

191 12 elevate_lock 0 4 236 32 LightReMutexDirect::elevate_lock 0 1 85 468
/**
 * This method increments the lock count, assuming the calling thread already
 * holds the lock.  After this call, release() will need to be called one
 * additional time to release the lock.
 *
 * This method really performs the same function as acquire(), but it offers a
 * potential (slight) performance benefit when the calling thread knows that
 * it already holds the lock.  It is an error to call this when the calling
 * thread does not hold the lock.
 */
57
inline void LightReMutexDirect::elevate_lock(void) const;

192 7 release 0 4 236 27 LightReMutexDirect::release 0 1 86 268
/**
 * Releases the lightReMutex.  It is an error to call this if the lightReMutex
 * was not already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * lightReMutexes, mainly to allow thread-safe access to otherwise const data.
 */
52
inline void LightReMutexDirect::release(void) const;

193 15 debug_is_locked 0 4 236 35 LightReMutexDirect::debug_is_locked 0 1 87 293
/**
 * Returns true if the current thread has locked the LightReMutex, false
 * otherwise.  This method is only intended for use in debugging, hence the
 * method name; in the LightReMutexDirect case, it always returns true, since
 * there's not a reliable way to determine this otherwise.
 */
60
inline bool LightReMutexDirect::debug_is_locked(void) const;

194 8 set_name 0 4 236 28 LightReMutexDirect::set_name 0 1 88 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
66
inline void LightReMutexDirect::set_name(std::string const &name);

195 10 clear_name 0 4 236 30 LightReMutexDirect::clear_name 0 1 89 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
49
inline void LightReMutexDirect::clear_name(void);

196 8 has_name 0 4 236 28 LightReMutexDirect::has_name 0 1 90 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
53
inline bool LightReMutexDirect::has_name(void) const;

197 8 get_name 0 4 236 28 LightReMutexDirect::get_name 0 1 91 79
/**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */
60
inline std::string LightReMutexDirect::get_name(void) const;

198 6 output 0 4 236 26 LightReMutexDirect::output 0 1 92 99
/**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * LightReMutexDirect.
 */
57
void LightReMutexDirect::output(std::ostream &out) const;

199 12 LightReMutex 0 4 237 26 LightReMutex::LightReMutex 0 2 93 94 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
109
inline LightReMutex::LightReMutex(void);
inline explicit LightReMutex::LightReMutex(std::string const &name);

200 13 ~LightReMutex 0 4 237 27 LightReMutex::~LightReMutex 0 0 0
44
LightReMutex::~LightReMutex(void) = default;

201 14 get_class_type 0 4 238 26 MainThread::get_class_type 0 1 95 0
51
static TypeHandle MainThread::get_class_type(void);

202 11 ~MainThread 0 4 238 23 MainThread::~MainThread 0 0 0
30
MainThread::~MainThread(void);

203 9 Semaphore 0 4 239 20 Semaphore::Semaphore 0 1 96 10
/**
 *
 */
60
inline explicit Semaphore::Semaphore(int initial_count = 1);

204 10 ~Semaphore 0 4 239 21 Semaphore::~Semaphore 0 0 0
38
Semaphore::~Semaphore(void) = default;

205 7 acquire 0 4 239 18 Semaphore::acquire 0 1 97 134
/**
 * Decrements the internal count.  If the count was already at zero, blocks
 * until the count is nonzero, then decrements it.
 */
37
inline void Semaphore::acquire(void);

206 11 try_acquire 0 4 239 22 Semaphore::try_acquire 0 1 98 117
/**
 * If the semaphore can be acquired without blocking, does so and returns
 * true.  Otherwise, returns false.
 */
41
inline bool Semaphore::try_acquire(void);

207 7 release 0 4 239 18 Semaphore::release 0 1 99 166
/**
 * Increments the semaphore's internal count.  This may wake up another thread
 * blocked on acquire().
 *
 * Returns the count of the semaphore upon release.
 */
36
inline int Semaphore::release(void);

208 9 get_count 0 4 239 20 Semaphore::get_count 0 1 100 127
/**
 * Returns the current semaphore count.  Note that this call is not thread-
 * safe (the count may change at any time).
 */
44
inline int Semaphore::get_count(void) const;

209 6 output 0 4 239 17 Semaphore::output 0 1 101 10
/**
 *
 */
48
void Semaphore::output(std::ostream &out) const;

210 12 PythonThread 0 4 240 26 PythonThread::PythonThread 0 1 102 0
127
explicit PythonThread::PythonThread(PyObject *function, PyObject *args, std::string const &name, std::string const &sync_name);

211 4 join 0 4 240 18 PythonThread::join 0 1 103 0
35
PyObject *PythonThread::join(void);

212 8 get_args 0 4 240 22 PythonThread::get_args 0 0 0
45
PyObject *PythonThread::get_args(void) const;

213 8 set_args 0 4 240 22 PythonThread::set_args 0 0 0
40
void PythonThread::set_args(PyObject *);

214 14 get_class_type 0 4 240 28 PythonThread::get_class_type 0 1 104 0
53
static TypeHandle PythonThread::get_class_type(void);

104
1 0 0 7 10 223 109 0 952 /**
 * Returns a new Panda Thread object associated with the current thread (which
 * has been created externally). This can be used to bind a unique Panda
 * Thread object with an external thread, such as a new Python thread.
 *
 * It is particularly useful to bind a Panda Thread object to an external
 * thread for the purposes of PStats monitoring.  Without this call, each
 * external thread will be assigned the same global ExternalThread object,
 * which means they will all appear in the same PStats graph.
 *
 * It is the caller's responsibility to save the returned Thread pointer for
 * the lifetime of the external thread.  It is an error for the Thread pointer
 * to destruct while the external thread is still in the system.
 *
 * It is also an error to call this method from the main thread, or twice
 * within a given thread, unless it is given the same name each time (in which
 * case the same pointer will be returned each time).
 */ 2 4 name 1 244  9 sync_name 1 244  
2 0 0 6 11 244 0 0 279 /**
 * Returns the sync name of the thread.  This name collects threads into "sync
 * groups", which are expected to run synchronously.  This is mainly used for
 * the benefit of PStats; threads with the same sync name can be ticked all at
 * once via the thread_tick() call.
 */ 1 4 this 3 245  
3 0 0 6 12 222 0 0 218 /**
 * Returns the PStats index associated with this thread, or -1 if no index has
 * yet been associated with this thread.  This is used internally by the
 * PStatClient; you should not need to call this directly.
 */ 1 4 this 3 245  
4 0 0 6 13 222 0 0 233 /**
 * Returns the Python index associated with this thread, or -1 if no index has
 * yet been associated with this thread.  This is used internally by the
 * direct.stdpy.thread module; you should not need to call this directly.
 */ 1 4 this 3 245  
5 0 0 6 14 244 0 0 161 /**
 * Returns a string that is guaranteed to be unique to this thread, across all
 * processes on the machine, during at least the lifetime of this process.
 */ 1 4 this 3 245  
6 0 0 6 15 222 0 0 163 /**
 * Returns the Pipeline stage number associated with this thread.  The default
 * stage is 0 if no stage is specified otherwise.  See set_pipeline_stage().
 */ 1 4 this 3 245  
7 0 0 4 16 247 0 0 479 /**
 * Specifies the Pipeline stage number associated with this thread.  The
 * default stage is 0 if no stage is specified otherwise.
 *
 * This must be a value in the range [0 .. pipeline->get_num_stages() - 1].
 * It specifies the values that this thread observes for all pipelined data.
 * Typically, an application thread will leave this at 0, but a render thread
 * may set it to 1 or 2 (to operate on the previous frame's data, or the
 * second previous frame's data).
 */ 2 4 this 3 223  14 pipeline_stage 1 222  
8 0 0 4 17 247 0 0 143 /**
 * Sets this thread's pipeline stage number to at least the indicated value,
 * unless it is already larger.  See set_pipeline_stage().
 */ 2 4 this 3 223  18 min_pipeline_stage 1 222  
9 0 0 7 18 223 109 0 111 /**
 * Returns a pointer to the "main" Thread object--this is the Thread that
 * started the whole process.
 */ 0 
10 0 0 7 19 223 109 0 248 /**
 * Returns a pointer to the "external" Thread object--this is a special Thread
 * object that corresponds to any thread spawned outside of Panda's threading
 * interface.  Note that multiple different threads may share this same
 * pointer.
 */ 0 
11 0 0 7 20 223 109 0 415 /**
 * Returns a pointer to the currently-executing Thread object.  If this is
 * called from the main thread, this will return the same value as
 * get_main_thread().
 *
 * This will always return some valid Thread pointer.  It will never return
 * NULL, even if the current thread was spawned outside of Panda's threading
 * system, although all non-Panda threads will return the exact same Thread
 * pointer.
 */ 0 
12 0 0 6 21 222 0 0 208 /**
 * Returns the integer pipeline stage associated with the current thread.
 * This is the same thing as get_current_thread()->get_pipeline_stage(), but
 * it may be faster to retrieve in some contexts.
 */ 0 
13 0 0 6 22 224 0 0 159 /**
 * Returns true if threading support has been compiled in and enabled, or
 * false if no threading is available (and Thread::start() will always fail).
 */ 0 
14 0 0 6 23 224 0 0 196 /**
 * Returns true if a real threading library is available that supports actual
 * OS-implemented threads, or false if the only threading we can provide is
 * simulated user-space threading.
 */ 0 
15 0 0 6 24 224 0 0 393 /**
 * Returns true if Panda is currently compiled for "simple threads", which is
 * to say, cooperative context switching only, reducing the need for quite so
 * many critical section protections.  This is not necessarily the opposite of
 * "true threads", since one possible implementation of simple threads is via
 * true threads with mutex protection to ensure only one runs at a time.
 */ 0 
16 0 0 4 25 247 0 0 119 /**
 * Suspends the current thread for at least the indicated amount of time.  It
 * might be suspended for longer.
 */ 1 7 seconds 1 248  
17 0 0 4 26 247 0 0 73 /**
 * Suspends the current thread for the rest of the current epoch.
 */ 0 
18 0 0 4 27 247 0 0 239 /**
 * Possibly suspends the current thread for the rest of the current epoch, if
 * it has run for enough this epoch.  This is especially important for the
 * simple thread implementation, which relies on cooperative yields like this.
 */ 0 
19 0 0 4 28 247 0 0 10 /**
 *
 */ 2 4 this 3 245  3 out 1 249  
20 0 0 4 29 247 0 0 184 /**
 * Writes a description of the mutex or condition variable that this thread is
 * blocked on.  Writes nothing if there is no blocker, or if we are not in
 * DEBUG_THREADS mode.
 */ 2 4 this 3 245  3 out 1 249  
21 0 0 4 30 247 0 0 10 /**
 *
 */ 1 3 out 1 249  
22 0 0 6 31 224 0 0 117 /**
 * Returns true if the thread has been started, false if it has not, or if
 * join() has already been called.
 */ 1 4 this 3 245  
23 0 0 6 32 224 0 0 77 /**
 * Returns the value of joinable that was passed to the start() call.
 */ 1 4 this 3 245  
24 0 0 6 33 224 0 0 862 /**
 * Starts the thread executing.  It is only valid to call this once.
 *
 * The thread will begin executing its thread_main() function, and will
 * terminate when thread_main() returns.
 *
 * priority is intended as a hint to the relative importance of this thread.
 * This may be ignored by the thread implementation.
 *
 * joinable should be set true if you intend to call join() to wait for the
 * thread to terminate, or false if you don't care and you will never call
 * join(). Note that the reference count on the Thread object is incremented
 * while the thread itself is running, so if you just want to fire and forget
 * a thread, you may pass joinable = false, and never store the Thread object.
 * It will automatically destruct itself when it finishes.
 *
 * The return value is true if the thread is successfully started, false
 * otherwise.
 */ 3 4 this 3 223  8 priority 1 215  8 joinable 1 224  
25 0 0 4 34 247 0 0 134 /**
 * Blocks the calling process until the thread terminates.  If the thread has
 * already terminated, this returns immediately.
 */ 1 4 this 3 223  
26 0 0 4 35 247 0 0 183 /**
 * Indicates that this thread should run as soon as possible, preemptying any
 * other threads that may be scheduled to run.  This may not be implemented on
 * every platform.
 */ 1 4 this 3 223  
27 0 0 7 36 225 0 0 161 /**
 * Returns the task currently executing on this thread (via the
 * AsyncTaskManager), if any, or NULL if the thread is not currently servicing
 * a task.
 */ 1 4 this 3 245  
28 0 0 4 37 247 0 0 160 /**
 * Stores a Python index to be associated with this thread.  This is used
 * internally by the thread module; you should not need to call this directly.
 */ 2 4 this 3 223  5 index 1 222  
29 0 0 4 38 247 0 0 143 /**
 * Should be called by the main thread just before exiting the program, this
 * blocks until any remaining thread cleanup has finished.
 */ 0 
30 0 0 7 61 252 0 0 0 0 
31 0 0 7 4 225 0 0 0 1 4 this 3 223  
32 0 0 6 7 253 0 0 0 1 4 this 3 223  
33 0 0 4 63 247 0 0 405 /**
 * Grabs the mutex if it is available.  If it is not available, blocks until
 * it becomes available, then grabs it.  In either case, the function does not
 * return until the mutex is held; you should then call unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * mutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see MutexHolder.
 */ 1 4 this 3 254  
34 0 0 6 64 224 0 0 204 /**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */ 1 4 this 3 254  
35 0 0 4 65 247 0 0 247 /**
 * Releases the mutex.  It is an error to call this if the mutex was not
 * already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * mutexes, mainly to allow thread-safe access to otherwise const data.
 */ 1 4 this 3 254  
36 0 0 6 66 224 0 0 278 /**
 * Returns true if the current thread has locked the Mutex, false otherwise.
 * This method is only intended for use in debugging, hence the method name;
 * in the MutexDirect case, it always returns true, since there's not a
 * reliable way to determine this otherwise.
 */ 1 4 this 3 254  
37 0 0 4 67 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 2 4 this 3 256  4 name 1 244  
38 0 0 4 68 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 256  
39 0 0 6 69 224 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 254  
40 0 0 6 70 244 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 254  
41 0 0 4 71 247 0 0 92 /**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * MutexDirect.
 */ 2 4 this 3 254  3 out 1 249  
42 0 0 7 73 257 150 0 10 /**
 *
 */ 0 
43 0 0 7 73 257 150 0 10 /**
 *
 */ 1 4 name 1 244  
44 0 0 6 75 224 0 0 0 2 4 this 3 258  8 blocking 1 224  
45 0 0 6 76 224 0 0 0 1 4 this 3 257  
46 0 0 4 77 247 0 0 0 4 4 this 3 257  6 param0 0 241  6 param1 0 241  6 param2 0 241  
47 0 0 6 80 256 0 0 69 /**
 * Returns the mutex associated with this condition variable.
 */ 1 4 this 3 260  
48 0 0 4 81 247 0 0 863 /**
 * Waits on the condition.  The caller must already be holding the lock
 * associated with the condition variable before calling this function.
 *
 * wait() will release the lock, then go to sleep until some other thread
 * calls notify() on this condition variable.  At that time at least one
 * thread waiting on the same ConditionVarDirect will grab the lock again, and
 * then return from wait().
 *
 * It is possible that wait() will return even if no one has called notify().
 * It is the responsibility of the calling process to verify the condition on
 * return from wait, and possibly loop back to wait again if necessary.
 *
 * Note the semantics of a condition variable: the mutex must be held before
 * wait() is called, and it will still be held when wait() returns.  However,
 * it will be temporarily released during the wait() call itself.
 */ 1 4 this 3 262  
49 0 0 4 81 247 0 0 327 /**
 * Waits on the condition, with a timeout.  The function will return when the
 * condition variable is notified, or the timeout occurs.  There is no way to
 * directly tell which happened, and it is possible that neither in fact
 * happened (spurious wakeups are possible).
 *
 * See wait() with no parameters for more.
 */ 2 4 this 3 262  7 timeout 1 248  
50 0 0 4 82 247 0 0 398 /**
 * Informs one of the other threads who are currently blocked on wait() that
 * the relevant condition has changed.  If multiple threads are currently
 * waiting, at least one of them will be woken up, although there is no way to
 * predict which one.  It is possible that more than one thread will be woken
 * up.
 *
 * If no threads are waiting, this is a no-op: the notify event is lost.
 */ 1 4 this 3 262  
51 0 0 4 83 247 0 0 199 /**
 * Informs all of the other threads who are currently blocked on wait() that
 * the relevant condition has changed.
 *
 * If no threads are waiting, this is a no-op: the notify event is lost.
 */ 1 4 this 3 262  
52 0 0 4 84 247 0 0 106 /**
 * This method is declared virtual in ConditionVarDebug, but non-virtual in
 * ConditionVarDirect.
 */ 2 4 this 3 260  3 out 1 249  
53 0 0 7 86 263 161 0 278 /**
 * You must pass in a Mutex to the condition variable constructor.  This mutex
 * may be shared by other condition variables, if desired.  It is the caller's
 * responsibility to ensure the Mutex object does not destruct during the
 * lifetime of the condition variable.
 */ 1 5 mutex 1 257  
54 0 0 6 88 257 0 0 69 /**
 * Returns the mutex associated with this condition variable.
 */ 1 4 this 3 264  
55 0 0 4 91 247 0 0 413 /**
 * Grabs the reMutex if it is available.  If it is not available, blocks until
 * it becomes available, then grabs it.  In either case, the function does not
 * return until the reMutex is held; you should then call unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * reMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see ReMutexHolder.
 */ 1 4 this 3 266  
56 0 0 4 91 247 0 0 126 /**
 * This variant on acquire() accepts the current thread as a parameter, if it
 * is already known, as an optimization.
 */ 2 4 this 3 266  14 current_thread 1 223  
57 0 0 6 92 224 0 0 204 /**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */ 1 4 this 3 266  
58 0 0 6 92 224 0 0 204 /**
 * Returns immediately, with a true value indicating the mutex has been
 * acquired, and false indicating it has not.
 *
 * @deprecated Python users should use acquire(False), C++ users try_lock()
 */ 2 4 this 3 266  14 current_thread 1 223  
59 0 0 4 93 247 0 0 468 /**
 * This method increments the lock count, assuming the calling thread already
 * holds the lock.  After this call, release() will need to be called one
 * additional time to release the lock.
 *
 * This method really performs the same function as acquire(), but it offers a
 * potential (slight) performance benefit when the calling thread knows that
 * it already holds the lock.  It is an error to call this when the calling
 * thread does not hold the lock.
 */ 1 4 this 3 266  
60 0 0 4 94 247 0 0 253 /**
 * Releases the reMutex.  It is an error to call this if the reMutex was not
 * already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * reMutexes, mainly to allow thread-safe access to otherwise const data.
 */ 1 4 this 3 266  
61 0 0 6 95 224 0 0 282 /**
 * Returns true if the current thread has locked the ReMutex, false otherwise.
 * This method is only intended for use in debugging, hence the method name;
 * in the ReMutexDirect case, it always returns true, since there's not a
 * reliable way to determine this otherwise.
 */ 1 4 this 3 266  
62 0 0 4 96 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 2 4 this 3 268  4 name 1 244  
63 0 0 4 97 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 268  
64 0 0 6 98 224 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 266  
65 0 0 6 99 244 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 266  
66 0 0 4 100 247 0 0 94 /**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * ReMutexDirect.
 */ 2 4 this 3 266  3 out 1 249  
67 0 0 7 102 269 174 0 10 /**
 *
 */ 0 
68 0 0 7 102 269 174 0 10 /**
 *
 */ 1 4 name 1 244  
69 0 0 6 104 224 0 0 0 2 4 this 3 270  8 blocking 1 224  
70 0 0 6 105 224 0 0 0 1 4 this 3 269  
71 0 0 4 106 247 0 0 0 4 4 this 3 269  6 param0 0 241  6 param1 0 241  6 param2 0 241  
72 0 0 7 108 252 0 0 0 0 
73 0 0 4 111 247 0 0 428 /**
 * Grabs the lightMutex if it is available.  If it is not available, blocks
 * until it becomes available, then grabs it.  In either case, the function
 * does not return until the lightMutex is held; you should then call
 * unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * lightMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see LightMutexHolder.
 */ 1 4 this 3 272  
74 0 0 4 112 247 0 0 262 /**
 * Releases the lightMutex.  It is an error to call this if the lightMutex was
 * not already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * lightMutexes, mainly to allow thread-safe access to otherwise const data.
 */ 1 4 this 3 272  
75 0 0 6 113 224 0 0 289 /**
 * Returns true if the current thread has locked the LightMutex, false
 * otherwise.  This method is only intended for use in debugging, hence the
 * method name; in the LightMutexDirect case, it always returns true, since
 * there's not a reliable way to determine this otherwise.
 */ 1 4 this 3 272  
76 0 0 4 114 247 0 0 84 /**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 2 4 this 3 274  4 name 1 244  
77 0 0 4 115 247 0 0 84 /**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 274  
78 0 0 6 116 224 0 0 84 /**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 272  
79 0 0 6 117 244 0 0 84 /**
 * The lightMutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 272  
80 0 0 4 118 247 0 0 102 /**
 * This method is declared virtual in LightMutexDebug, but non-virtual in
 * LightMutexDirect.
 */ 2 4 this 3 272  3 out 1 249  
81 0 0 7 120 275 189 0 10 /**
 *
 */ 0 
82 0 0 7 120 275 189 0 10 /**
 *
 */ 1 4 name 1 244  
83 0 0 4 123 247 0 0 436 /**
 * Grabs the lightReMutex if it is available.  If it is not available, blocks
 * until it becomes available, then grabs it.  In either case, the function
 * does not return until the lightReMutex is held; you should then call
 * unlock().
 *
 * This method is considered const so that you can lock and unlock const
 * lightReMutexes, mainly to allow thread-safe access to otherwise const data.
 *
 * Also see LightReMutexHolder.
 */ 1 4 this 3 276  
84 0 0 4 123 247 0 0 126 /**
 * This variant on acquire() accepts the current thread as a parameter, if it
 * is already known, as an optimization.
 */ 2 4 this 3 276  14 current_thread 1 223  
85 0 0 4 124 247 0 0 468 /**
 * This method increments the lock count, assuming the calling thread already
 * holds the lock.  After this call, release() will need to be called one
 * additional time to release the lock.
 *
 * This method really performs the same function as acquire(), but it offers a
 * potential (slight) performance benefit when the calling thread knows that
 * it already holds the lock.  It is an error to call this when the calling
 * thread does not hold the lock.
 */ 1 4 this 3 276  
86 0 0 4 125 247 0 0 268 /**
 * Releases the lightReMutex.  It is an error to call this if the lightReMutex
 * was not already locked.
 *
 * This method is considered const so that you can lock and unlock const
 * lightReMutexes, mainly to allow thread-safe access to otherwise const data.
 */ 1 4 this 3 276  
87 0 0 6 126 224 0 0 293 /**
 * Returns true if the current thread has locked the LightReMutex, false
 * otherwise.  This method is only intended for use in debugging, hence the
 * method name; in the LightReMutexDirect case, it always returns true, since
 * there's not a reliable way to determine this otherwise.
 */ 1 4 this 3 276  
88 0 0 4 127 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 2 4 this 3 278  4 name 1 244  
89 0 0 4 128 247 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 278  
90 0 0 6 129 224 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 276  
91 0 0 6 130 244 0 0 79 /**
 * The mutex name is only defined when compiling in DEBUG_THREADS mode.
 */ 1 4 this 3 276  
92 0 0 4 131 247 0 0 99 /**
 * This method is declared virtual in MutexDebug, but non-virtual in
 * LightReMutexDirect.
 */ 2 4 this 3 276  3 out 1 249  
93 0 0 7 133 279 200 0 10 /**
 *
 */ 0 
94 0 0 7 133 279 200 0 10 /**
 *
 */ 1 4 name 1 244  
95 0 0 7 136 252 0 0 0 0 
96 0 0 7 139 280 204 0 10 /**
 *
 */ 1 13 initial_count 1 222  
97 0 0 4 141 247 0 0 134 /**
 * Decrements the internal count.  If the count was already at zero, blocks
 * until the count is nonzero, then decrements it.
 */ 1 4 this 3 280  
98 0 0 6 142 224 0 0 117 /**
 * If the semaphore can be acquired without blocking, does so and returns
 * true.  Otherwise, returns false.
 */ 1 4 this 3 280  
99 0 0 6 143 222 0 0 166 /**
 * Increments the semaphore's internal count.  This may wake up another thread
 * blocked on acquire().
 *
 * Returns the count of the semaphore upon release.
 */ 1 4 this 3 280  
100 0 0 6 144 222 0 0 127 /**
 * Returns the current semaphore count.  Note that this call is not thread-
 * safe (the count may change at any time).
 */ 1 4 this 3 281  
101 0 0 4 145 247 0 0 10 /**
 *
 */ 2 4 this 3 281  3 out 1 249  
102 0 0 7 147 283 109 0 0 4 8 function 1 241  4 args 1 241  4 name 1 244  9 sync_name 1 244  
103 0 0 6 148 241 0 0 0 1 4 this 3 283  
104 0 0 7 155 252 0 0 0 0 
69
215 14 ThreadPriority 0 532481 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0
0 9 TP_normal 9 TP_normal 0
1 7 TP_high 7 TP_high 0
2 9 TP_urgent 9 TP_urgent 0
3 0 105
// An enumerated type used by Thread to specify a suggested relative priority
// for a particular thread.

216 6 Thread 0 26625 6 Thread 6 Thread 0 0 0 0 109 15 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 30 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 0 0 2 3 217 105 106 3 218 107 108 0 0 396
/**
 * A thread; that is, a lightweight process.  This is an abstract base class;
 * to use it, you must subclass from it and redefine thread_main().
 *
 * The thread itself will keep a reference count on the Thread object while it
 * is running; when the thread returns from its root function, the Thread
 * object will automatically be destructed if no other pointers are
 * referencing it.
 */

217 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

218 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

219 12 string const 0 8832 17 std::string const 17 std::string const 0 0 220 0 0 0 0 0 0 0 0 0 0

220 6 string 0 2105344 11 std::string 11 std::string 0 0 221 0 0 0 0 0 0 0 0 0 0

221 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

222 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

223 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 216 0 0 0 0 0 0 0 0 0 0

224 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

225 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 217 0 0 0 0 0 0 0 0 0 0

226 11 MutexDirect 0 43009 11 MutexDirect 11 MutexDirect 0 0 0 0 0 0 9 140 141 142 143 144 145 146 147 148 0 0 0 0 0 164
/**
 * This class implements a standard mutex by making direct calls to the
 * underlying implementation layer.  It doesn't perform any debugging
 * operations.
 */

227 5 Mutex 0 26625 5 Mutex 5 Mutex 0 0 0 1 149 150 0 3 151 152 153 0 0 1 0 226 0 0 0 0 0

228 18 ConditionVarDirect 0 26625 18 ConditionVarDirect 18 ConditionVarDirect 0 0 0 0 154 0 5 155 156 157 158 159 0 0 0 0 0 377
/**
 * A condition variable, usually used to communicate information about
 * changing state to a thread that is waiting for something to happen.  A
 * condition variable can be used to "wake up" a thread when some arbitrary
 * condition has changed.
 *
 * A condition variable is associated with a single mutex, and several
 * condition variables may share the same mutex.
 */

229 12 ConditionVar 0 26625 12 ConditionVar 12 ConditionVar 0 0 0 1 160 161 0 1 162 0 0 1 0 228 0 0 0 0 0

230 16 ConditionVarFull 0 2105345 16 ConditionVarFull 16 ConditionVarFull 0 0 229 0 0 0 0 0 0 0 0 0 0

231 13 ReMutexDirect 0 43009 13 ReMutexDirect 13 ReMutexDirect 0 0 0 0 0 0 10 163 164 165 166 167 168 169 170 171 172 0 0 0 0 0 166
/**
 * This class implements a standard reMutex by making direct calls to the
 * underlying implementation layer.  It doesn't perform any debugging
 * operations.
 */

232 7 ReMutex 0 26625 7 ReMutex 7 ReMutex 0 0 0 1 173 174 0 3 175 176 177 0 0 1 0 231 0 0 0 0 0

233 14 ExternalThread 0 141313 14 ExternalThread 14 ExternalThread 0 0 0 0 179 0 1 178 0 0 1 0 216 0 0 0 0 149
/**
 * The special "external thread" class.  There is one instance of these in the
 * world, and it is returned by Thread::get_external_thread().
 */

234 16 LightMutexDirect 0 43009 16 LightMutexDirect 16 LightMutexDirect 0 0 0 0 0 0 8 180 181 182 183 184 185 186 187 0 0 0 0 0 167
/**
 * This class implements a lightweight Mutex by making direct calls to the
 * underlying implementation layer.  It doesn't perform any debugging
 * operations.
 */

235 10 LightMutex 0 26625 10 LightMutex 10 LightMutex 0 0 0 1 188 189 0 0 0 0 1 0 234 0 0 0 0 0

236 18 LightReMutexDirect 0 43009 18 LightReMutexDirect 18 LightReMutexDirect 0 0 0 0 0 0 9 190 191 192 193 194 195 196 197 198 0 0 0 0 0 171
/**
 * This class implements a standard lightReMutex by making direct calls to the
 * underlying implementation layer.  It doesn't perform any debugging
 * operations.
 */

237 12 LightReMutex 0 26625 12 LightReMutex 12 LightReMutex 0 0 0 1 199 200 0 0 0 0 1 0 236 0 0 0 0 0

238 10 MainThread 0 141313 10 MainThread 10 MainThread 0 0 0 0 202 0 1 201 0 0 1 0 216 0 0 0 0 141
/**
 * The special "main thread" class.  There is one instance of these in the
 * world, and it is returned by Thread::get_main_thread().
 */

239 9 Semaphore 0 26625 9 Semaphore 9 Semaphore 0 0 0 1 203 204 0 5 205 206 207 208 209 0 0 0 0 0 332
/**
 * A classic semaphore synchronization primitive.
 *
 * A semaphore manages an internal counter which is decremented by each
 * acquire() call and incremented by each release() call.  The counter can
 * never go below zero; when acquire() finds that it is zero, it blocks,
 * waiting until some other thread calls release().
 */

240 12 PythonThread 0 75777 12 PythonThread 12 PythonThread 0 0 0 1 210 109 1 299 2 211 214 0 0 1 0 216 0 0 0 0 174
/**
 * This class is exposed to Python to allow creation of a Panda thread from
 * the Python level.  It will spawn a thread that executes an arbitrary Python
 * functor.
 */

241 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 242 0 0 0 0 0 0 0 0 0 0

242 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 243 0 0 0 0 0 0 0 0 0 0

243 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

244 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

245 14 Thread const * 0 8576 14 Thread const * 14 Thread const * 0 0 246 0 0 0 0 0 0 0 0 0 0

246 12 Thread const 0 8832 12 Thread const 12 Thread const 0 0 216 0 0 0 0 0 0 0 0 0 0

247 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

248 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

249 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 250 0 0 0 0 0 0 0 0 0 0

250 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

251 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

252 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 251 0 0 0 0 0 0 0 0 0 0

253 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 218 0 0 0 0 0 0 0 0 0 0

254 19 MutexDirect const * 0 8576 19 MutexDirect const * 19 MutexDirect const * 0 0 255 0 0 0 0 0 0 0 0 0 0

255 17 MutexDirect const 0 8832 17 MutexDirect const 17 MutexDirect const 0 0 226 0 0 0 0 0 0 0 0 0 0

256 13 MutexDirect * 0 8576 13 MutexDirect * 13 MutexDirect * 0 0 226 0 0 0 0 0 0 0 0 0 0

257 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 227 0 0 0 0 0 0 0 0 0 0

258 13 Mutex const * 0 8576 13 Mutex const * 13 Mutex const * 0 0 259 0 0 0 0 0 0 0 0 0 0

259 11 Mutex const 0 8832 11 Mutex const 11 Mutex const 0 0 227 0 0 0 0 0 0 0 0 0 0

260 26 ConditionVarDirect const * 0 8576 26 ConditionVarDirect const * 26 ConditionVarDirect const * 0 0 261 0 0 0 0 0 0 0 0 0 0

261 24 ConditionVarDirect const 0 8832 24 ConditionVarDirect const 24 ConditionVarDirect const 0 0 228 0 0 0 0 0 0 0 0 0 0

262 20 ConditionVarDirect * 0 8576 20 ConditionVarDirect * 20 ConditionVarDirect * 0 0 228 0 0 0 0 0 0 0 0 0 0

263 14 ConditionVar * 0 8576 14 ConditionVar * 14 ConditionVar * 0 0 229 0 0 0 0 0 0 0 0 0 0

264 20 ConditionVar const * 0 8576 20 ConditionVar const * 20 ConditionVar const * 0 0 265 0 0 0 0 0 0 0 0 0 0

265 18 ConditionVar const 0 8832 18 ConditionVar const 18 ConditionVar const 0 0 229 0 0 0 0 0 0 0 0 0 0

266 21 ReMutexDirect const * 0 8576 21 ReMutexDirect const * 21 ReMutexDirect const * 0 0 267 0 0 0 0 0 0 0 0 0 0

267 19 ReMutexDirect const 0 8832 19 ReMutexDirect const 19 ReMutexDirect const 0 0 231 0 0 0 0 0 0 0 0 0 0

268 15 ReMutexDirect * 0 8576 15 ReMutexDirect * 15 ReMutexDirect * 0 0 231 0 0 0 0 0 0 0 0 0 0

269 9 ReMutex * 0 8576 9 ReMutex * 9 ReMutex * 0 0 232 0 0 0 0 0 0 0 0 0 0

270 15 ReMutex const * 0 8576 15 ReMutex const * 15 ReMutex const * 0 0 271 0 0 0 0 0 0 0 0 0 0

271 13 ReMutex const 0 8832 13 ReMutex const 13 ReMutex const 0 0 232 0 0 0 0 0 0 0 0 0 0

272 24 LightMutexDirect const * 0 8576 24 LightMutexDirect const * 24 LightMutexDirect const * 0 0 273 0 0 0 0 0 0 0 0 0 0

273 22 LightMutexDirect const 0 8832 22 LightMutexDirect const 22 LightMutexDirect const 0 0 234 0 0 0 0 0 0 0 0 0 0

274 18 LightMutexDirect * 0 8576 18 LightMutexDirect * 18 LightMutexDirect * 0 0 234 0 0 0 0 0 0 0 0 0 0

275 12 LightMutex * 0 8576 12 LightMutex * 12 LightMutex * 0 0 235 0 0 0 0 0 0 0 0 0 0

276 26 LightReMutexDirect const * 0 8576 26 LightReMutexDirect const * 26 LightReMutexDirect const * 0 0 277 0 0 0 0 0 0 0 0 0 0

277 24 LightReMutexDirect const 0 8832 24 LightReMutexDirect const 24 LightReMutexDirect const 0 0 236 0 0 0 0 0 0 0 0 0 0

278 20 LightReMutexDirect * 0 8576 20 LightReMutexDirect * 20 LightReMutexDirect * 0 0 236 0 0 0 0 0 0 0 0 0 0

279 14 LightReMutex * 0 8576 14 LightReMutex * 14 LightReMutex * 0 0 237 0 0 0 0 0 0 0 0 0 0

280 11 Semaphore * 0 8576 11 Semaphore * 11 Semaphore * 0 0 239 0 0 0 0 0 0 0 0 0 0

281 17 Semaphore const * 0 8576 17 Semaphore const * 17 Semaphore const * 0 0 282 0 0 0 0 0 0 0 0 0 0

282 15 Semaphore const 0 8832 15 Semaphore const 15 Semaphore const 0 0 239 0 0 0 0 0 0 0 0 0 0

283 14 PythonThread * 0 8576 14 PythonThread * 14 PythonThread * 0 0 240 0 0 0 0 0 0 0 0 0 0

0
16
284 9 sync_name 0 2 219 111 0 0 0 0 0 0 0 17 Thread::sync_name 0

285 12 pstats_index 0 2 222 112 0 0 0 0 0 0 0 20 Thread::pstats_index 0

286 12 python_index 0 2 222 113 0 0 0 0 0 0 0 20 Thread::python_index 0

287 9 unique_id 0 2 220 114 0 0 0 0 0 0 0 17 Thread::unique_id 0

288 14 pipeline_stage 0 6 222 115 116 0 0 0 0 0 0 22 Thread::pipeline_stage 0

289 11 main_thread 0 2 223 118 0 0 0 0 0 0 0 19 Thread::main_thread 0

290 15 external_thread 0 2 223 119 0 0 0 0 0 0 0 23 Thread::external_thread 0

291 14 current_thread 0 2 223 120 0 0 0 0 0 0 0 22 Thread::current_thread 0

292 22 current_pipeline_stage 0 2 222 121 0 0 0 0 0 0 0 30 Thread::current_pipeline_stage 0

293 19 threading_supported 0 2 224 122 0 0 0 0 0 0 0 27 Thread::threading_supported 0

294 12 true_threads 0 2 224 123 0 0 0 0 0 0 0 20 Thread::true_threads 0

295 14 simple_threads 0 2 224 124 0 0 0 0 0 0 0 22 Thread::simple_threads 0

296 7 started 0 2 224 131 0 0 0 0 0 0 0 15 Thread::started 0

297 8 joinable 0 2 224 132 0 0 0 0 0 0 0 16 Thread::joinable 0

298 12 current_task 0 2 225 136 0 0 0 0 0 0 0 20 Thread::current_task 0

299 4 args 0 6 241 212 213 0 0 0 0 0 0 18 PythonThread::args 0

0
