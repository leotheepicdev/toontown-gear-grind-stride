from kpi.internal import MsgTypes
from panda3d.direct import DCPacker


class KryptonDatabaseInterface:
    notify = directNotify.newCategory('KryptonDatabaseInterface')
    dbChannel = 4003

    def __init__(self, air):
        self.air = air

        self._context = 0
        self._callbacks = dict()
        self._queries = dict()

    @property
    def context(self):
        self._context = (self._context + 1) & 0xFFFFFFFF
        return self._context

    def query(self, doId, callback, dclassName, fieldName):
        """
        Queries the configured database channel for the specified DCField name
        associated with the doId. Krypton does not support querying multiple
        fields in one request yet. DCFields that are molecular are also not yet
        supported.

        :param doId: DistributedObject ID
        :param callback: Will be called with the DCField object and the corresponding
        value after the internal interface receives a response. Both values will be
        None if the query is unsuccessful.
        :param dclassName: The name of the object's DClass in the DCFile as a string.
        :param fieldName: The name of the DCField we are querying for as a string.
        """
        context = self.context
        self._callbacks[context] = callback

        dclass = dcFile.getClassByName(dclassName)
        field = dclass.getFieldByName(fieldName)

        self._queries[context] = field

        dg = self.air.createRoutedDatagram(MsgTypes.DATABASE_OBJECT_GET_FIELD, channels=(self.dbChannel,))
        dg.addUint32(context)
        dg.addUint32(doId)
        dg.addUint16(field.getNumber())
        self.air.sendUpstream(dg)

    def queryAll(self, doId, callback):
        """
        Queries the configured database channel for every DCField marked with the
        db keyword for the specified doId.

        :param doId: DistributedObject ID
        :param callback: Will be called with the DClass object and the corresponding
        dictionary of keys and values for DCFields after the internal interface receives a response.
        Both values will be None if the query is unsuccessful.
        """
        context = self.context
        self._callbacks[context] = callback

        dg = self.air.createRoutedDatagram(MsgTypes.DATABASE_OBJECT_GET_ALL, channels=(self.dbChannel,))
        dg.addUint32(context)
        dg.addUint32(doId)
        self.air.sendUpstream(dg)

    def queryBatch(self, doIds, callback, dclassName, fieldName):
        """
        Queries the configured database channel for the specified DCField name
        associated with each doId in doIds.

        :param doIds: The DistributedObject IDs
        :param callback: Will be called with the DCField object and a list of tuples containing an objectId and value.
        :param dclassName: The name of the object's DClass in the DCFile as a string.
        :param fieldName: The name of the DCField we are querying for as a string.
        """
        context = self.context
        self._callbacks[context] = callback

        dclass = dcFile.getClassByName(dclassName)
        field = dclass.getFieldByName(fieldName)

        self._queries[context] = field

        dg = self.air.createRoutedDatagram(MsgTypes.DATABASE_OBJECT_BATCH_GET_FIELD, channels=(self.dbChannel,))
        dg.addUint32(context)
        dg.addUint16(field.getNumber())
        dg.addUint16(len(doIds))
        for doId in doIds:
            dg.addUint32(doId)
        self.air.sendUpstream(dg)

    def update(self, doId, dclassName, fieldName, value):
        """
        Sends an update to the configured database channel to change
        the specified DCField name to the provided value for the provided doId.
        Krypton does not support updating multiple fields in one request yet.
        DCFields that are molecular are also not yet supported.

        :param doId: DistributedObject ID
        :param dclassName: The name of the object's DClass in the DCFile as a string.
        :param fieldName: The name of the DCField we are requesting an update for as a string.
        :param value: The value of the DCField we are requesting an update for as a tuple of arguments.
        """
        dg = self.air.createRoutedDatagram(MsgTypes.DATABASE_OBJECT_SET_FIELD, channels=(self.dbChannel,))
        dg.addUint32(doId)

        dclass = dcFile.getClassByName(dclassName)
        field = dclass.getFieldByName(fieldName)

        packer = DCPacker()
        packer.rawPackUint16(field.getNumber())
        packer.beginPack(field)
        field.packArgs(packer, value)
        packer.endPack()
        dg.appendData(packer.getBytes())

        self.air.sendUpstream(dg)

    def handleQueryResp(self, msgType, dgi):
        context = dgi.getUint32()
        if context not in self._callbacks:
            self.notify.warning('Received unknown context: %d' % context)
            return

        success = dgi.getUint8()

        try:
            if not success:
                self._callbacks[context](None, None)
                return

            if msgType == MsgTypes.DATABASE_OBJECT_GET_ALL_RESP:
                dclassId = dgi.getUint16()
                dclass = dcFile.getClass(dclassId)

                fieldCount = dgi.getUint16()

                unpacker = DCPacker()
                unpacker.setUnpackData(dgi.getRemainingBytes())

                fields = dict()
                for i in range(fieldCount):
                    fieldId = unpacker.rawUnpackInt16()
                    field = dclass.getFieldByIndex(fieldId)

                    if not field:
                        self.notify.error('Received bad field %d in query for %s object' % (fieldId, dclass.getName()))

                    unpacker.beginUnpack(field)
                    fields[field.getName()] = field.unpackArgs(unpacker)
                    unpacker.endUnpack()

                self._callbacks[context](dclass, fields)
            elif msgType == MsgTypes.DATABASE_OBJECT_GET_FIELD_RESP:
                field = self._queries[context]
                unpacker = DCPacker()
                unpacker.setUnpackData(dgi.getRemainingBytes())
                unpacker.beginUnpack(field)
                data = field.unpackArgs(unpacker)
                unpacker.endUnpack()
                self._callbacks[context](field, data)
        finally:
            del self._callbacks[context]

            if context in self._queries:
                del self._queries[context]

    def handleBatchQueryResp(self, dgi):
        context = dgi.getUint32()
        if context not in self._callbacks:
            self.notify.warning('Received unknown context: %d' % context)
            return

        field = self._queries[context]
        batch = []

        unpacker = DCPacker()
        unpacker.setUnpackData(dgi.getRemainingBytes())

        batchCount = unpacker.rawUnpackUint16()
        for _ in range(batchCount):
            success = unpacker.rawUnpackUint8()
            objectId = unpacker.rawUnpackUint32()
            if success:
                unpacker.beginUnpack(field)
                data = field.unpackArgs(unpacker)
                unpacker.endUnpack()
                batch.append((objectId, data))
            else:
                batch.append((objectId, None))

        self._callbacks[context](field, batch)
