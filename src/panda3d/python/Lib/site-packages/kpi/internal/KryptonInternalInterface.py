import sys

from panda3d.core import SocketAddress, SocketUDPOutgoing
from pandac.PandaModules import DCPacker

from direct.distributed.PyDatagramIterator import PyDatagramIterator
from direct.distributed.PyDatagram import PyDatagram
from direct.directnotify.DirectNotifyGlobal import directNotify

from kpi.net.EventNetworkConnector import EventNetworkConnector
from kpi.net.NetworkConnector import NetworkConnector
from kpi.internal.KryptonDatabaseInterface import KryptonDatabaseInterface
from kpi.internal import MsgTypes
from kpi.internal import Types
from kpi.util.UIDGenerator import UIDGenerator
from kpi.internal.NetMessenger import NetMessenger

import time


class KryptonInternalInterface(NetworkConnector):
    notify = directNotify.newCategory('KryptonInternalInterface')

    def __init__(self, mdHost, mdPort, channel, maxChannels, stateserverChannel,
                 dynamicZoneStart, dynamicZoneEnd, dclassConstructos, name):
        NetworkConnector.__init__(self, mdHost, mdPort)

        self.channel = channel
        self.groupId = Types.UBER if name == 'UberDOG' else Types.AI
        self.maxChannels = maxChannels
        self.stateserverChannel = stateserverChannel
        self.name = name

        self.dclassConstructors = dclassConstructos

        self.doIdAllocator = UIDGenerator(min=self.channel+1, max=self.channel+1000000)
        self.zoneIdAllocator = UIDGenerator(min=dynamicZoneStart, max=dynamicZoneEnd)

        self.eventSocket = None  # Socket for EventLogger, if enabled.

        self.doId2do = {}  # A dict of ids to objects.

        self.lastSender = 0  # The channel of the last sender.

        self.netMessenger = NetMessenger(self)

        self.dbInterface = KryptonDatabaseInterface(self)

        self.registerForChannel(self.channel)

        self.handleConnected()

    def registerForChannel(self, channel):
        # Subscribe to our channel.
        dg = self.createHandledDatagram(MsgTypes.CONTROL_ADD_CHANNEL)
        dg.addUint64(channel)  # Channel we want to subscribe to.

        # Send the datagram to the message director.
        self.sendUpstream(dg)

    def handleConnected(self):
        pass

    def lostConnection(self):
        print('Lost connection to gameserver!')
        sys.exit()

    def getChannelIdFromSender(self):
        return self.lastSender

    def allocateZone(self):
        return self.zoneIdAllocator.request()

    def deallocateZone(self, zoneId):
        self.zoneIdAllocator.free(zoneId)

    def createRoutedDatagram(self, msgType, channels=()):
        """
        Creates a datagram that will be routed by the Message Director.
        """
        dg = PyDatagram()
        dg.addUint8(len(channels))  # Number of channels.

        for channel in channels:
            dg.addUint64(channel)  # Destination channel.

        dg.addUint64(self.channel)  # Source channel.
        dg.addUint8(self.groupId)
        dg.addUint16(msgType)  # Message type.
        return dg

    def createHandledDatagram(self, msgType):
        """
        Creates a datagram that will be handled on the Message Director.
        """
        dg = PyDatagram()
        dg.addUint8(1)  # One channel.
        dg.addUint64(Types.MD_PARTICIPANT)  # have the participant handle it
        dg.addUint16(msgType)  # Message type.
        return dg

    def handleServerDatagram(self, dg):
        """
        Handles a datagram sent by the Message Director.
        """

        dgi = PyDatagramIterator(dg)

        self.lastSender = dgi.getUint64()
        groupId = dgi.getUint8()
        msgType = dgi.getUint16()

        # Check to see if the message is something defined outside of the framework
        if (8000 <= msgType <= 8999) or msgType >= 11000:
            self.handleUniqueDatagram(dgi, msgType)
            return

        # Handle the message:
        if msgType in (MsgTypes.OBJECT_ENTER_AI_WITH_REQUIRED,
                       MsgTypes.OBJECT_ENTER_AI_WITH_REQUIRED_OTHER):
            self.handleObjectEntry(dgi, other=msgType == MsgTypes.OBJECT_ENTER_AI_WITH_REQUIRED_OTHER)
        elif msgType == MsgTypes.OBJECT_CHANGING_LOCATION:
            self.handleObjectLocation(dgi)
        elif msgType == MsgTypes.OBJECT_SET_FIELD:
            self.handleObjectSetField(dgi)
        elif msgType in (MsgTypes.OBJECT_CHANGING_AI,
                         MsgTypes.OBJECT_DELETE_RAM):
            self.handleObjectExit(dgi)
        elif msgType in (MsgTypes.DATABASE_OBJECT_GET_ALL_RESP, MsgTypes.DATABASE_OBJECT_GET_FIELD_RESP):
            self.dbInterface.handleQueryResp(msgType, dgi)
        elif msgType == MsgTypes.DATABASE_OBJECT_BATCH_GET_FIELD_RESP:
            self.dbInterface.handleBatchQueryResp(dgi)

    def handleUniqueDatagram(self, dgi, msgType):
        # These messages belong to the NetMessenger:
        self.netMessenger.handle(msgType, dgi)

    def handleObjectEntry(self, dgi, other=False):
        objectType = dgi.getUint8()  # TODO: Handle multiple object types.
        doId = dgi.getUint32()

        # Ignore the object if we already have it in our doId2do:
        if doId in self.doId2do:
            return

        # Get the dclass for the object and create the DistributedObject:
        classId = dgi.getUint16()
        dclass = dcFile.getClass(classId)

        # Get the location
        parentId = dgi.getUint32()
        zoneId = dgi.getUint32()

        do = self.dclassConstructors[dclass.getName()](self)
        do.dclass = dclass
        do.doId = doId
        do.setLocation(parentId, zoneId)
        do.deallocateChannel = False  # We don't deallocate because this is an object we didn't generate.

        self.doId2do[doId] = do

        # Now we generate the object:
        do.generate()
        if other:
            do.updateAllRequiredOtherFields(dgi)
        else:
            do.updateAllRequiredFields(dgi)

    def handleObjectLocation(self, dgi):
        doId = dgi.getUint32()
        parentId = dgi.getUint32()
        zoneId = dgi.getUint32()

        do = self.doId2do.get(doId)

        # Ignore the message, this is information we already know.
        if do is None and (parentId == 0 and zoneId == 0):
            return

        if do is None:
            print('Received location for unknown doId={doId}!, loc=({parentId}, {zoneId})'
                  .format(doId=doId, parentId=parentId, zoneId=zoneId))
            return

        do.setLocation(parentId, zoneId)

    def handleObjectSetField(self, dgi):
        doId = dgi.getUint32()
        do = self.doId2do.get(doId)
        if do is None:
            print('Received update for unknown doId=%d!' % doId)
            return

        do.dclass.receiveUpdate(do, dgi)

    def handleObjectExit(self, dgi):
        doId = dgi.getUint32()

        do = self.doId2do.get(doId)
        if do is None:
            print('Received exit for unknown doId=%s!' % doId)
            return

        self.delete(do)

    def sendUpdate(self, do, fieldName, args):
        self.sendUpdateToChannel(do, do.doId, fieldName, args)

    def sendUpdateToChannel(self, do, channel, fieldName, args):
        dg = self.createRoutedDatagram(MsgTypes.OBJECT_SET_FIELD, [channel])

        # Get the field
        field = do.dclass.getFieldByName(fieldName)

        # Create the DCPacker
        packer = DCPacker()
        packer.rawPackUint32(do.doId)
        packer.rawPackUint16(field.getNumber())

        # Pack the args
        packer.beginPack(field)
        field.packArgs(packer, args)
        packer.endPack()

        # Add the packer to dg
        dg.appendData(packer.getBytes())

        # Send the dg upstream
        self.sendUpstream(dg)

    def sendSetLocation(self, do, parentId, zoneId):
        dg = self.createRoutedDatagram(MsgTypes.OBJECT_SET_LOCATION, [do.doId])
        dg.addUint32(do.doId)
        dg.addUint32(parentId)
        dg.addUint16(zoneId)
        self.sendUpstream(dg)

    def generateWithRequired(self, do, parentId, zoneId):
        doId = self.doIdAllocator.request()
        self.generateWithRequiredAndId(do, doId, parentId, zoneId)

    def generateWithRequiredAndId(self, do, doId, parentId, zoneId):
        do.doId = doId
        self.doId2do[doId] = do
        do.sendGenerateWithRequired(parentId, zoneId)

    def generateExtensiveWithRequired(self, do, parentId, startZone, endZone):
        doId = self.doIdAllocator.request()
        self.generateExtensiveWithRequiredAndId(do, doId, parentId, startZone, endZone)

    def generateExtensiveWithRequiredAndId(self, do, doId, parentId, startZone, endZone):
        do.doId = doId
        self.doId2do[doId] = do
        do.sendGenerateExtensiveWithRequired(parentId, startZone, endZone)

    def getAvatarExitEvent(self, avId):
        return 'delete-%s' % avId

    def requestDelete(self, do):
        dg = self.createRoutedDatagram(MsgTypes.OBJECT_DELETE_RAM, [do.doId])
        dg.addUint32(do.doId)
        self.sendUpstream(dg)

    def delete(self, do):
        if do.doId not in self.doId2do:
            print('Tried deleting unknown object! %s' % do.doId)
            return

        del self.doId2do[do.doId]
        do.deleted = True
        do.delete()
        # Only delete ID's we allocated ourselves.
        if self.doIdAllocator.contains(do.doId):
            self.doIdAllocator.free(do.doId)
        do.air = None

    def addPostRemove(self, dg):
        dg2 = self.createHandledDatagram(MsgTypes.CONTROL_ADD_POST_REMOVE)
        dg2.appendData(dg.getMessage())
        self.sendUpstream(dg2)

    def setEventLogHost(self, host, port=6668):
        """
        Set the target host for Event Logger messaging. This should be pointed
        at the UDP IP:port that hosts the cluster's running Event Logger.

        Providing a value of None or an empty string for 'host' will disable
        event logging.
        """

        if not host:
            self.eventSocket = None
            return

        address = SocketAddress()
        if not address.setHost(host, port):
            self.notify.warning('Invalid Event Log host specified: %s:%s' % (host, port))
            self.eventSocket = None
        else:
            self.eventSocket = EventNetworkConnector(host, port)

    def writeServerEvent(self, event, doId, message):
        """
        Sends the indicated event data to the event server via UDP for
        recording and/or statistics gathering.
        """
        if self.eventSocket is None:
            return

        eventDg = PyDatagram()
        eventDg.addUint32(int(time.time()))
        eventDg.addString(event)
        eventDg.addString(str(doId))
        eventDg.addString(message)

        dg = PyDatagram()
        dg.addUint16(eventDg.getLength())
        dg.appendData(eventDg.getMessage())
        try:
            self.eventSocket.sendUpstream(dg)
        except Exception as e:
            print('Couldnt log event due to exception')
            print(e)
