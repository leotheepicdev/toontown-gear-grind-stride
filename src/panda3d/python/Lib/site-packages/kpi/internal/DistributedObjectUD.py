from kpi.internal.DistributedObjectAI import DistributedObjectAI

from kpi.util.UniqueObject import UniqueObject
from kpi.internal import MsgTypes

from direct.showbase.DirectObject import DirectObject
from direct.showbase.PythonUtil import Functor
from direct.distributed.PyDatagram import PyDatagram

from .Barrier import Barrier


class DistributedObjectUD(UniqueObject, DirectObject):
    QuietZone = 1

    def __init__(self, air):
        DirectObject.__init__(self)

        self.air = air
        self.doId = None
        dclassName = self.__class__.__name__
        if dclassName.endswith('UD'):
            dclassName = dclassName[:-2]
        self.dclass = dcFile.getClassByName(dclassName)
        self.zoneId = None
        self.parentId = None
        self.generated = False
        self.deleted = False
        self.deallocateChannel = True

        # These are used to implement beginBarrier().
        self.__nextBarrierContext = 0
        self.__barriers = {}

        self._zoneData = None
        self.lastNonQuietZone = None

    def isGenerated(self):
        return self.generated

    def isDeleted(self):
        return self.deleted

    def isEmpty(self):
        return self.deleted  # TODO: Figure out what this does.

    def generate(self):
        pass

    def announceGenerate(self):
        pass

    def postGenerateMessage(self):
        self.generated = True
        messenger.send('generate-%s' % self.doId, [self])

    def requestDelete(self):
        if self.air is None:
            doId = getattr(self, "doId", -1)
            print('Tried to delete an already deleted do: %s' % doId)
            return

        self.air.requestDelete(self)

    def delete(self):
        self.releaseZoneData()
        messenger.send('delete-%s' % self.doId)

    def updateAllRequiredFields(self, dgi):
        self.dclass.receiveUpdateAllRequired(self, dgi)
        self.announceGenerate()
        self.postGenerateMessage()

    def updateAllRequiredOtherFields(self, dgi):
        self.dclass.receiveUpdateAllRequired(self, dgi)

        # Announce generate after updating all the required fields,
        # but before we update the non-required fields.
        self.announceGenerate()
        self.postGenerateMessage()

        self.dclass.receiveUpdateOther(self, dgi)

    def generateGlobalWithRequired(self):
        self.air.generateGlobalWithRequired(self, self.air.channel)
        self.generate()
        self.announceGenerate()
        self.postGenerateMessage()

    def generateExtensiveWithRequired(self, startZone, endZone):
        self.air.generateExtensiveWithRequired(self, self.air.channel, startZone, endZone)
        self.generate()
        self.announceGenerate()
        self.postGenerateMessage()

    def generateWithRequired(self, zoneId):
        self.air.generateWithRequired(self, self.air.channel, zoneId)
        self.generate()
        self.announceGenerate()
        self.postGenerateMessage()

    def generateWithRequiredAndId(self, doId, parentId, zoneId):
        self.air.generateWithRequiredAndId(self, doId, parentId, zoneId)
        self.generate()
        self.announceGenerate()
        self.postGenerateMessage()

    def sendUpdate(self, fieldName, args=()):
        self.air.sendUpdate(self, fieldName, args)

    def sendUpdateToAvatarId(self, avatarId, fieldName, args):
        self.air.sendUpdateToChannel(self, avatarId, fieldName, args)

    def sendGenerateWithRequired(self, parentId, zoneId):
        dg = self.air.createRoutedDatagram(MsgTypes.STATESERVER_CREATE_OBJECT_WITH_REQUIRED,
                                           [self.air.stateserverChannel])

        dg.addUint32(self.doId)
        dg.addUint32(parentId)
        dg.addUint32(zoneId)
        dg.addUint16(self.dclass.getNumber())

        # Iterate through all the fields.
        fieldCount = self.dclass.getNumInheritedFields()
        for i in range(fieldCount):
            field = self.dclass.getInheritedField(i)

            # If the field is molecular we want to skip it.
            if field.asMolecularField() is not None:
                continue

            # We only want fields that are required.
            if not field.isRequired():
                continue

            # Pack the data
            try:
                self.dclass.packRequiredField(dg, self, field)
            except Exception as e:
                print('Failed to pack required field {field} for {dclass}'.format(field=field, dclass=self.dclass))
                raise e

        # Send the dg upstream
        self.air.sendUpstream(dg)

    def sendGenerateExtensiveWithRequired(self, parentId, startZone, endZone):
        dg = self.air.createRoutedDatagram(MsgTypes.STATESERVER_CREATE_EXTENSIVE_OBJECT_WITH_REQUIRED,
                                           [self.air.stateserverChannel])

        dg.addUint32(self.doId)
        dg.addUint32(parentId)
        dg.addUint32(startZone)
        dg.addUint32(endZone)
        dg.addUint16(self.dclass.getNumber())

        # Iterate through all the fields.
        fieldCount = self.dclass.getNumInheritedFields()
        for i in range(fieldCount):
            field = self.dclass.getInheritedField(i)

            # If the field is molecular we want to skip it.
            if field.asMolecularField() is not None:
                continue

            # We only want fields that are required.
            if not field.isRequired():
                continue

            # Pack the data
            self.dclass.packRequiredField(dg, self, field)

        # Send the dg upstream
        self.air.sendUpstream(dg)

    def setAI(self, channel):
        dg = self.air.createRoutedDatagram(MsgTypes.OBJECT_SET_AI, [self.doId])
        dg.addUint64(channel)
        self.air.sendUpstream(dg)

    def claimOwnership(self):
        dg = self.air.createRoutedDatagram(MsgTypes.OBJECT_SET_OWNER, [self.doId])
        dg.addUint64(self.air.channel)
        self.air.sendUpstream(dg)

    def b_setLocation(self, parentId, zoneId):
        self.d_setLocation(parentId, zoneId)
        self.setLocation(parentId, zoneId)

    def d_setLocation(self, parentId, zoneId):
        dg = self.air.createRoutedDatagram(MsgTypes.OBJECT_SET_LOCATION, [self.doId])
        dg.addUint32(parentId)
        dg.addUint32(zoneId)
        self.air.sendUpstream(dg)

    def setLocation(self, parentId, zoneId):
        # Prevent Duplicate SetLocations for being Called
        if (self.parentId == parentId) and (self.zoneId == zoneId):
            return

        oldParentId = self.parentId
        oldZoneId = self.zoneId

        self.parentId = parentId
        self.zoneId = zoneId

        if not self.isGenerated():
            return

        if (oldParentId != parentId) or (oldZoneId != zoneId):
            self.releaseZoneData()
            messenger.send(self.getZoneChangeEvent(), [zoneId, oldZoneId])
            # if we are not going into the quiet zone, send a 'logical' zone
            # change message
            if zoneId != DistributedObjectAI.QuietZone:
                lastLogicalZone = oldZoneId
                if oldZoneId == DistributedObjectAI.QuietZone:
                    lastLogicalZone = self.lastNonQuietZone
                self.handleLogicalZoneChange(zoneId, lastLogicalZone)
                self.lastNonQuietZone = zoneId

    def getLocation(self):
        return self.parentId, self.zoneId

    def getZoneChangeEvent(self):
        # this event is generated whenever this object changes zones.
        # arguments are newZoneId, oldZoneId
        # includes the quiet zone.
        return DistributedObjectAI.staticGetZoneChangeEvent(self.doId)

    def getLogicalZoneChangeEvent(self):
        # this event is generated whenever this object changes to a
        # non-quiet-zone zone.
        # arguments are newZoneId, oldZoneId
        # does not include the quiet zone.
        return DistributedObjectAI.staticGetLogicalZoneChangeEvent(self.doId)

    @staticmethod
    def staticGetZoneChangeEvent(doId):
        return 'DOChangeZone-%s' % doId

    @staticmethod
    def staticGetLogicalZoneChangeEvent(doId):
        return 'DOLogicalChangeZone-%s' % doId

    def handleLogicalZoneChange(self, newZoneId, oldZoneId):
        """this function gets called as if we never go through the
        quiet zone. Note that it is called once you reach the newZone,
        and not at the time that you leave the oldZone."""
        messenger.send(self.getLogicalZoneChangeEvent(),
                       [newZoneId, oldZoneId])

    def validate(self, avId, bool, msg):
        if not bool:
            self.air.writeServerEvent('suspicious', avId, msg)
        return bool

    def beginBarrier(self, name, avIds, timeout, callback):
        # Begins waiting for a set of avatars.  When all avatars in
        # the list have reported back in or the callback has expired,
        # calls the indicated callback with the list of avatars that
        # made it through.  There may be multiple barriers waiting
        # simultaneously on different lists of avatars, although they
        # should have different names.

        context = self.__nextBarrierContext
        # We assume the context number is passed as a uint16.
        self.__nextBarrierContext = (self.__nextBarrierContext + 1) & 0xffff

        if avIds:
            barrier = Barrier(name, self.uniqueName(name), avIds, timeout,
                              doneFunc=Functor(self.__barrierCallback, context, callback))
            self.__barriers[context] = barrier

            # Send the context number to each involved client.
            self.sendUpdate("setBarrierData", [self.getBarrierData()])

        else:
            # No avatars; just call the callback immediately.
            callback(avIds)

        return context

    def getBarrierData(self):
        # Returns the barrier data formatted for sending to the
        # clients.  This lists all of the current outstanding barriers
        # and the avIds waiting for them.
        data = []
        for context, barrier in self.__barriers.items():
            avatars = barrier.pendingAvatars
            if avatars:
                data.append((context, barrier.name, avatars))
        return data

    def ignoreBarrier(self, context):
        # Aborts a previously-set barrier.  The context is the return
        # value from the previous call to beginBarrier().
        barrier = self.__barriers.get(context)
        if barrier:
            barrier.cleanup()
            del self.__barriers[context]

    def setBarrierReady(self, context):
        # Generated by the clients to check in after a beginBarrier()
        # call.
        avId = self.air.getAvatarIdFromSender()
        barrier = self.__barriers.get(context)
        if barrier == None:
            # This may be None if a client was slow and missed an
            # earlier timeout.  Too bad.
            return

        barrier.clear(avId)

    def __barrierCallback(self, context, callback, avIds):
        # The callback that is generated when a barrier is completed.
        barrier = self.__barriers.get(context)
        if barrier:
            barrier.cleanup()
            del self.__barriers[context]
            callback(avIds)

    def releaseZoneData(self):
        pass
